/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita-swift
 */
import Foundation
import BeetSolana
import Solana
import Beet


/**
* Arguments used to create {@link Listingreceipt}
* @category Accounts
* @category generated
*/
protocol ListingreceiptArgs {
    
    var tradeState: PublicKey { get }
    var bookkeeper: PublicKey { get }
    var auctionHouse: PublicKey { get }
    var seller: PublicKey { get }
    var metadata: PublicKey { get }
    var purchaseReceipt: COption<PublicKey> { get }
    var price: UInt64 { get }
    var tokenSize: UInt64 { get }
    var bump: UInt8 { get }
    var tradeStateBump: UInt8 { get }
    var createdAt: Int64 { get }
    var canceledAt: COption<Int64> { get }
}


/**
 * Holds the data for the {@link Listingreceipt} Account and provides de/serialization
 * functionality for that data
 *
 * @category Accounts
 * @category generated
 */
public struct Listingreceipt: ListingreceiptArgs {
  let tradeState: PublicKey
  let bookkeeper: PublicKey
  let auctionHouse: PublicKey
  let seller: PublicKey
  let metadata: PublicKey
  let purchaseReceipt: COption<PublicKey>
  let price: UInt64
  let tokenSize: UInt64
  let bump: UInt8
  let tradeStateBump: UInt8
  let createdAt: Int64
  let canceledAt: COption<Int64>

  /**
   * Creates a {@link Listingreceipt} instance from the provided args.
   */
  static func fromArgs(args: Args) -> Listingreceipt {
    return Listingreceipt(
        tradeState: args["tradeState"] as! PublicKey,
        bookkeeper: args["bookkeeper"] as! PublicKey,
        auctionHouse: args["auctionHouse"] as! PublicKey,
        seller: args["seller"] as! PublicKey,
        metadata: args["metadata"] as! PublicKey,
        purchaseReceipt: args["purchaseReceipt"] as! COption<PublicKey>,
        price: args["price"] as! UInt64,
        tokenSize: args["tokenSize"] as! UInt64,
        bump: args["bump"] as! UInt8,
        tradeStateBump: args["tradeStateBump"] as! UInt8,
        createdAt: args["createdAt"] as! Int64,
        canceledAt: args["canceledAt"] as! COption<Int64>
    )
  }
  /**
   * Deserializes the {@link Listingreceipt} from the data of the provided {@link web3.AccountInfo}.
   * @returns a tuple of the account data and the offset up to which the buffer was read to obtain it.
   */
  static func fromAccountInfo(
    accountInfo: Data,
    offset:Int=0
  ) -> ( Listingreceipt, Int )  {
    return Listingreceipt.deserialize(buf: accountInfo, offset: offset)
  }
  /**
   * Retrieves the account info from the provided address and deserializes
   * the {@link Listingreceipt} from its data.
   *
   * @throws Error if no account info is found at the address or if deserialization fails
   */
  static func fromAccountAddress(
    connection: Api,
    address: PublicKey,
    onComplete: @escaping (Result<Listingreceipt, Error>) -> Void
  ) {
    connection.getAccountInfo(account: address.base58EncodedString) { result in
        switch result {
            case .success(let pureData):
                if let data = pureData.data?.value {
                    onComplete(.success(Listingreceipt.deserialize(buf: data).0))
                } else {
                    onComplete(.failure(SolanaError.nullValue))
                }
            case .failure(let error):
                onComplete(.failure(error))
        }
    }
  }
  /**
   * Deserializes the {@link Listingreceipt} from the provided data Buffer.
   * @returns a tuple of the account data and the offset up to which the buffer was read to obtain it.
   */
  static func deserialize(
    buf: Data,
    offset: Int = 0
  ) -> ( Listingreceipt, Int ) {
    return listingReceiptBeet.deserialize(buffer: buf, offset: offset)
  }
  /**
   * Serializes the {@link Listingreceipt} into a Buffer.
   * @returns a tuple of the created Buffer and the offset up to which the buffer was written to store it.
   */
  func serialize() -> ( Data, Int ) {
    return listingReceiptBeet.serialize(instance: [
        "tradeState" : self.tradeState,
        "bookkeeper" : self.bookkeeper,
        "auctionHouse" : self.auctionHouse,
        "seller" : self.seller,
        "metadata" : self.metadata,
        "purchaseReceipt" : self.purchaseReceipt,
        "price" : self.price,
        "tokenSize" : self.tokenSize,
        "bump" : self.bump,
        "tradeStateBump" : self.tradeStateBump,
        "createdAt" : self.createdAt,
        "canceledAt" : self.canceledAt
        ])
  }
  /**
* Returns the byteSize of a {@link Buffer} holding the serialized data of
* {@link Listingreceipt} for the provided args.
*
* @param args need to be provided since the byte size for this account
* depends on them
*/
static func byteSize(args: ListingreceiptArgs) -> UInt64 {
    return UInt64(listingReceiptBeet.toFixedFromValue(val: args).byteSize)
}
/**
* Fetches the minimum balance needed to exempt an account holding
* {@link Listingreceipt} data from rent
*
* @param args need to be provided since the byte size for this account
* depends on them
* @param connection used to retrieve the rent exemption information
*/
static func getMinimumBalanceForRentExemption(
    args: ListingreceiptArgs,
    connection: Api,
    commitment: Commitment?,
    onComplete: @escaping(Result<UInt64, Error>) -> Void
) {
    return connection.getMinimumBalanceForRentExemption(dataLength: Listingreceipt.byteSize(args: args), commitment: commitment, onComplete: onComplete)
}
}
  /**
   * @category Accounts
   * @category generated
   */
  public let listingReceiptBeet = FixableBeetStruct<Listingreceipt>(
    fields:[
        
        ("tradeState", Beet.fixedBeet(.init(value: .scalar(BeetPublicKey())))),
        ("bookkeeper", Beet.fixedBeet(.init(value: .scalar(BeetPublicKey())))),
        ("auctionHouse", Beet.fixedBeet(.init(value: .scalar(BeetPublicKey())))),
        ("seller", Beet.fixedBeet(.init(value: .scalar(BeetPublicKey())))),
        ("metadata", Beet.fixedBeet(.init(value: .scalar(BeetPublicKey())))),
        ("purchaseReceipt", Beet.fixableBeat(coption(inner: Beet.fixedBeet(.init(value: .scalar(BeetPublicKey())))))),
        ("price", Beet.fixedBeet(.init(value: .scalar(u64())))),
        ("tokenSize", Beet.fixedBeet(.init(value: .scalar(u64())))),
        ("bump", Beet.fixedBeet(.init(value: .scalar(u8())))),
        ("tradeStateBump", Beet.fixedBeet(.init(value: .scalar(u8())))),
        ("createdAt", Beet.fixedBeet(.init(value: .scalar(i64())))),
        ("canceledAt", Beet.fixableBeat(coption(inner: Beet.fixedBeet(.init(value: .scalar(i64()))))))
    ],
    construct: Listingreceipt.fromArgs,
    description: "Listingreceipt"
)
